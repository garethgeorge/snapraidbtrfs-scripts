#!/bin/bash

#
# This script scans for Btrfs filesystems with patterns 'oceand{nn}' (data)
# and 'oceanp{nn}' (parity). It generates /etc/fstab entries for all of them
# and also creates a mergerfs entry to pool only the data disks at /ocean.
# It will print a warning if a duplicate label is found.
#

# --- Script Configuration ---
FILESYSTEM_TYPE="btrfs"
# This pattern matches both 'oceand##' and 'oceanp##'
LABEL_PATTERN="^ocean[dp][0-9][0-9]$"
# This pattern matches ONLY data disks for the mergerfs pool
DATA_LABEL_PATTERN="^oceand[0-9][0-9]$"
MOUNT_OPTIONS="defaults,noatime,nofail"

# MergerFS configuration
MERGERFS_MOUNT_POINT="/ocean"
MERGERFS_RESTRICT_TO_SUBDIR="/ocean" # only share files from each disk's /ocean subdirectory
# Options explained:
# allow_other: lets non-root users see the mount
# use_ino: helps applications that track files by inode
# category.create=eplfs: (Existing Path, Least Free Space) a smart policy for creating new files
# minfreespace=500G: stops writing to a disk when it has less than 500GB free
# fsname=oceanpool: a descriptive name that will appear in commands like `df`
MERGERFS_OPTIONS="defaults,allow_other,use_ino,category.create=eplfs,minfreespace=500G,fsname=oceanpool"

# --- Main Logic ---

# Header for the output
echo "# --- Start of generated Btrfs fstab entries for ocean disks ---"
echo "# Generated by script on $(date)"
echo ""

# Use lsblk to find devices and pipe to awk for processing.
lsblk -n -o UUID,LABEL,FSTYPE | \
awk -v fstype="$FILESYSTEM_TYPE" \
    -v pattern="$LABEL_PATTERN" \
    -v data_pattern="$DATA_LABEL_PATTERN" \
    -v options="$MOUNT_OPTIONS" \
    -v mergerfs_mp="$MERGERFS_MOUNT_POINT" \
    -v mergerfs_opts="$MERGERFS_OPTIONS" \
    -v mergerfs_restrict="$MERGERFS_RESTRICT_TO_SUBDIR" \
'
# BEGIN block runs once before processing any input.
BEGIN {
    merger_paths = ""
    # This array will track the UUID of the first device seen for each label.
    delete seen_labels
}
# This is the main processing block. It runs for each line from lsblk.
{
    uuid = $1
    label = $2
    fs = $3
    # If the label has a value (is not empty)
    if (label != "") {
        # Check if we have already processed this label.
        if (label in seen_labels) {
            # This is a duplicate. Print a warning to stderr and skip.
            printf "WARNING: Duplicate label '\''%s'\'' detected. Original UUID: %s, Conflicting UUID: %s. Ignoring conflicting device.\n", label, seen_labels[label], uuid > "/dev/stderr"
            next
        }
    }
    # Check if the filesystem type and label match our general pattern (ocean[dp]##)
    if (fs == fstype && label ~ pattern) {
        # Mark this label as seen by storing the UUID of the device.
        seen_labels[label] = uuid
        mount_point = "/mnt/" label mergerfs_restrict
        # Print the fstab line for the individual disk (data or parity)
        printf "UUID=%-36s %-20s %-6s %-20s 0 0\n", uuid, mount_point, fstype, options
        # ONLY if the label matches the data disk pattern, add it to the mergerfs list.
        if (label ~ data_pattern) {
            if (merger_paths == "") {
                merger_paths = mount_point
            } else {
                merger_paths = merger_paths ":" mount_point 
            }
        }
    }
}
# END block runs once after all input has been processed.
END {
    # If we found any data disks, create the mergerfs entry for them.
    if (merger_paths != "") {
        printf "\n# MergerFS pool for data disks (oceand##)\n"
        # The first field for mergerfs is the colon-separated list of paths to merge
        printf "%-37s %-20s %-10s %-s 0 0\n", merger_paths, mergerfs_mp, "mergerfs", mergerfs_opts
    }
}
'

echo ""
echo "# --- End of generated Btrfs fstab entries ---"
