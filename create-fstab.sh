#!/bin/bash

#
# This script scans for Btrfs filesystems with labels 'oceand{nn}' (data)
# and 'oceanp{nn}' (parity). It generates /etc/fstab entries for all of them.
# If a filesystem is on a LUKS encrypted device, it also generates the
# corresponding /etc/crypttab entry.
# Finally, it creates a mergerfs entry to pool only the data disks at /ocean.
# It will print a warning if a duplicate Btrfs label is found.
#
# NEW: This script will temporarily unlock any found LUKS devices using a shared
# key file to inspect the filesystem labels within them. It must be run as root.
#

# --- Script Configuration ---
FILESYSTEM_TYPE="btrfs"
# This pattern matches both 'oceand##' and 'oceanp##'
LABEL_PATTERN="^ocean[dp][0-9][0-9]$"
# This pattern matches ONLY data disks for the mergerfs pool
DATA_LABEL_PATTERN="^oceand[0-9][0-9]$"
MOUNT_OPTIONS="defaults,noatime,nofail"

# LUKS configuration
# The script assumes a single, shared key file for all encrypted ocean disks.
# IMPORTANT: Secure this file! (e.g., chmod 600, owned by root)
LUKS_KEY_FILE="/mnt/usb-secrets/ocean_luks_key"
LUKS_OPTIONS="luks,discard"

# MergerFS configuration
MERGERFS_MOUNT_POINT="/ocean"
MERGERFS_RESTRICT_TO_SUBDIR="/ocean" # only share files from each disk's /ocean subdirectory
# Options explained:
# allow_other: lets non-root users see the mount
# use_ino: helps applications that track files by inode
# category.create=eplfs: (Existing Path, Least Free Space) a smart policy for creating new files
# minfreespace=500G: stops writing to a disk when it has less than 500GB free
# fsname=oceanpool: a descriptive name that will appear in commands like `df`
MERGERFS_OPTIONS="defaults,allow_other,use_ino,category.create=eplfs,minfreespace=500G,fsname=oceanpool"

# --- Main Logic ---

# Check for root privileges, required for cryptsetup
if [ "$(id -u)" -ne 0 ]; then
    echo "This script must be run as root to unlock LUKS devices." >&2
    exit 1
fi

# --- State Variables ---
declare -a opened_devices
declare -A crypttab_entries
declare -A fstab_entries
declare -A seen_labels
merger_paths=""

# --- Cleanup Function ---
# This function will run when the script exits, ensuring temporary devices are closed.
function cleanup {
    if [ ${#opened_devices[@]} -gt 0 ]; then
        echo ""
        echo "# --- Cleaning up temporary LUKS devices ---"
        for mapper_name in "${opened_devices[@]}"; do
            echo "# Closing $mapper_name..."
            cryptsetup close "$mapper_name"
        done
    fi
}
trap cleanup EXIT

# Header for the output
echo "# --- Start of generated crypttab and fstab entries for ocean disks ---"
echo "# Generated by script on $(date)"
echo ""

# --- Unlock LUKS devices and process them ---
# Find all devices with FSTYPE="crypto_LUKS"
luks_devices=$(lsblk -n -o NAME,FSTYPE | awk '$2 == "crypto_LUKS" {print $1}')

if [ -n "$luks_devices" ]; then
    echo "# --- Attempting to unlock and process LUKS devices ---"
    for device in $luks_devices; do
        device_path="/dev/$device"
        mapper_name="tmp_unlock_$(basename "$device")"

        # Try to unlock the device
        if ! cryptsetup open "$device_path" "$mapper_name" --key-file "$LUKS_KEY_FILE" --type luks -T1 &>/dev/null; then
            echo "# Could not unlock $device_path (already open, or wrong key?)"
            continue
        fi
        echo "# Successfully unlocked $device_path"
        opened_devices+=("$mapper_name")
        
        # Now that it's open, inspect the filesystem inside
        mapper_path="/dev/mapper/$mapper_name"
        # Get LABEL and UUID for the Btrfs filesystem inside the LUKS container using a safer read command
        read -r BTRFS_LABEL BTRFS_UUID <<< "$(lsblk -n -o LABEL,UUID -f "$mapper_path")"

        # Get UUID of the physical LUKS container, ensuring we only get the crypto_LUKS UUID
        LUKS_UUID=$(lsblk -n -o FSTYPE,UUID -f "$device_path" | awk '$1 == "crypto_LUKS" {print $2}')

        # Check if the label matches our pattern
        if [[ "$BTRFS_LABEL" =~ $LABEL_PATTERN ]]; then
            # Check for duplicates
            if [[ -n "${seen_labels[$BTRFS_LABEL]}" ]]; then
                echo "WARNING: Duplicate Btrfs label '$BTRFS_LABEL' detected. Ignoring device $device_path." >&2
                continue
            fi
            seen_labels["$BTRFS_LABEL"]=1

            # Generate entries
            crypttab_entries["$BTRFS_LABEL"]="$BTRFS_LABEL UUID=$LUKS_UUID $LUKS_KEY_FILE $LUKS_OPTIONS"
            fstab_entries["$BTRFS_LABEL"]="UUID=$BTRFS_UUID /mnt/$BTRFS_LABEL $FILESYSTEM_TYPE $MOUNT_OPTIONS 0 0"
            
            # Add to mergerfs if it's a data disk
            if [[ "$BTRFS_LABEL" =~ $DATA_LABEL_PATTERN ]]; then
                 if [ -z "$merger_paths" ]; then
                    merger_paths="/mnt/$BTRFS_LABEL$MERGERFS_RESTRICT_TO_SUBDIR"
                else
                    merger_paths="$merger_paths:/mnt/$BTRFS_LABEL$MERGERFS_RESTRICT_TO_SUBDIR"
                fi
            fi
        fi
    done
    echo ""
fi

# --- Process unencrypted Btrfs devices ---
# (This part of the logic was missing from the previous version)
echo "# --- Processing any unencrypted Btrfs devices ---"
# Find all Btrfs filesystems that are NOT on a LUKS device (PKNAME is null or not a LUKS device)
# This is a simplified approach; a more robust solution would be more complex.
# For now, we just find all Btrfs devices and check if we've already processed them.
unencrypted_devices=$(lsblk -n -o NAME,TYPE,FSTYPE,LABEL,UUID | awk '$3 == "btrfs" && $2 == "part" {print $1, $4, $5}')
while read -r device label uuid; do
    if [[ "$label" =~ $LABEL_PATTERN ]] && [[ -z "${seen_labels[$label]}" ]]; then
        echo "# Found unencrypted device /dev/$device with label $label"
        seen_labels["$label"]=1
        fstab_entries["$label"]="UUID=$uuid /mnt/$label $FILESYSTEM_TYPE $MOUNT_OPTIONS 0 0"
        if [[ "$label" =~ $DATA_LABEL_PATTERN ]]; then
            if [ -z "$merger_paths" ]; then
                merger_paths="/mnt/$label$MERGERFS_RESTRICT_TO_SUBDIR"
            else
                merger_paths="$merger_paths:/mnt/$label$MERGERFS_RESTRICT_TO_SUBDIR"
            fi
        fi
    fi
done <<< "$unencrypted_devices"
echo ""


# --- Print Generated Configuration ---

# Print crypttab entries if any were generated.
if [ ${#crypttab_entries[@]} -gt 0 ]; then
    echo "# --- crypttab entries ---"
    # Sort keys for consistent output
    for label in $(echo "${!crypttab_entries[@]}" | tr ' ' '\n' | sort);
    do
        echo "${crypttab_entries[$label]}"
    done
    echo ""
fi

# Print fstab entries.
if [ ${#fstab_entries[@]} -gt 0 ]; then
    echo "# --- fstab entries for individual disks ---"
    for label in $(echo "${!fstab_entries[@]}" | tr ' ' '\n' | sort);
    do
        echo "${fstab_entries[$label]}"
    done
    echo ""
fi

# Print the mergerfs entry if any data disks were found.
if [ -n "$merger_paths" ]; then
    echo "# MergerFS pool for data disks"
    mergerfs_line="$merger_paths $MERGERFS_MOUNT_POINT mergerfs $MERGERFS_OPTIONS 0 0"
    echo "$mergerfs_line"
fi

echo ""
echo "# --- End of generated entries ---"