#!/bin/bash
#
# This script scans for PARTITIONS with GPT labels 'oceand{nn}' (data)
# and 'oceanp{nn}' (parity). It assumes these partitions are LUKS containers.
# It generates /etc/fstab and /etc/crypttab entries for all found devices.
# Finally, it creates a mergerfs entry to pool only the data disks at /ocean.
#
# This script must be run as root to unlock LUKS devices for inspection.
#

# --- Script Configuration ---
FILESYSTEM_TYPE="btrfs"
# This pattern matches partition labels like 'oceand01', 'oceanp01', etc.
PARTLABEL_PATTERN="^ocean[dp][0-9][0-9]$"
# This pattern matches ONLY data disks for the mergerfs pool
DATA_LABEL_PATTERN="^oceand[0-9][0-9]$"
MOUNT_OPTIONS="defaults,noatime,nofail"

# LUKS configuration
LUKS_KEY_FILE="/etc/keys/ocean_luks_key"
LUKS_OPTIONS="luks,discard"

# MergerFS configuration
MERGERFS_MOUNT_POINT="/ocean"
MERGERFS_RESTRICT_TO_SUBDIR="/ocean"
MERGERFS_OPTIONS="defaults,allow_other,use_ino,category.create=eplfs,minfreespace=500G,fsname=oceanpool"

# --- Main Logic ---

# 1. Check for root privileges
if [ "$(id -u)" -ne 0 ]; then
    echo "This script must be run as root to unlock LUKS devices." >&2
    exit 1
fi

# --- State Variables ---
declare -a opened_devices
declare -A crypttab_entries
declare -A fstab_entries
merger_paths=""

# --- Cleanup Function ---
function cleanup {
    if [ ${#opened_devices[@]} -gt 0 ]; then
        echo ""
        echo "# --- Cleaning up temporary LUKS devices ---"
        for mapper_name in "${opened_devices[@]}"; do
            echo "# Closing $mapper_name..."
            cryptsetup close "$mapper_name" &>/dev/null || true
        done
    fi
}
trap cleanup EXIT

# --- Header ---
echo "# --- Start of generated crypttab and fstab entries for ocean disks ---"
echo "# Generated by script on $(date)"
echo ""

# --- Find and Process Labeled Partitions ---
echo "# --- Scanning for partitions with labels matching '$PARTLABEL_PATTERN' ---"
# Use process substitution to read the loop variables in the current shell.
# This prevents variable scoping issues where the arrays would be empty after the loop.
while read -r type partlabel device; do
    # Skip if the partition label doesn't match our pattern
    if ! [[ "$partlabel" =~ $PARTLABEL_PATTERN ]]; then
        continue
    fi
    
    device_path="/dev/$device"
    echo "# Found labeled partition '$partlabel' on $device_path"

    # --- Get LUKS UUID ---
    # Get the UUID of the LUKS container on the partition
    LUKS_UUID=$(lsblk -n -o FSTYPE,UUID -f "$device_path" | awk '$1 == "crypto_LUKS" {print $2}')
    if [ -z "$LUKS_UUID" ]; then
        echo "WARNING: Partition '$partlabel' does not appear to be a LUKS device. Skipping." >&2
        continue
    fi

    # --- Get Btrfs UUID (by unlocking) ---
    mapper_path="/dev/mapper/$partlabel"
    
    # Check if the device is already open. If not, try to open it.
    if [ ! -e "$mapper_path" ]; then
        echo "# Device is not open. Attempting to unlock..."
        if ! cryptsetup open "$device_path" "$partlabel" --key-file "$LUKS_KEY_FILE" --type luks -T1 &>/dev/null; then
            echo "WARNING: Could not unlock '$partlabel' on $device_path. Skipping." >&2
            continue
        fi
        # Add to the list of devices we need to close on exit
        opened_devices+=("$partlabel")
    else
        echo "# Device is already open. Proceeding."
    fi
    
    # Read the Btrfs UUID from inside the container
    BTRFS_UUID=$(lsblk -n -o FSTYPE,UUID -f "$mapper_path" | awk '$1 == "btrfs" {print $2}')
    if [ -z "$BTRFS_UUID" ]; then
        echo "WARNING: No Btrfs filesystem found inside '$partlabel'. Skipping." >&2
        # If we just opened it, close it now since we're skipping.
        if [[ " ${opened_devices[*]} " =~ " ${partlabel} " ]]; then
            cryptsetup close "$partlabel"
            opened_devices=("${opened_devices[@]/$partlabel}")
        fi
        continue
    fi

    # --- Generate Configuration Entries ---
    crypttab_entries["$partlabel"]="$partlabel UUID=$LUKS_UUID $LUKS_KEY_FILE $LUKS_OPTIONS"
    fstab_entries["$partlabel"]="UUID=$BTRFS_UUID /mnt/$partlabel $FILESYSTEM_TYPE $MOUNT_OPTIONS 0 0"

    # Add to mergerfs if it's a data disk
    if [[ "$partlabel" =~ $DATA_LABEL_PATTERN ]]; then
        if [ -z "$merger_paths" ]; then
            merger_paths="/mnt/$partlabel$MERGERFS_RESTRICT_TO_SUBDIR"
        else
            merger_paths="$merger_paths:/mnt/$partlabel$MERGERFS_RESTRICT_TO_SUBDIR"
        fi
    fi
done < <(lsblk -n -o TYPE,PARTLABEL,NAME --sort PARTLABEL | awk '$1 == "part" && $2')
echo ""

# --- Print Generated Configuration ---

# Print crypttab entries
if [ ${#crypttab_entries[@]} -gt 0 ]; then
    echo "# --- crypttab entries ---"
    for label in $(echo "${!crypttab_entries[@]}" | tr ' ' '\n' | sort);
    do
        echo "${crypttab_entries[$label]}"
    done
    echo ""
fi

# Print fstab entries
if [ ${#fstab_entries[@]} -gt 0 ]; then
    echo "# --- fstab entries for individual disks ---"
    for label in $(echo "${!fstab_entries[@]}" | tr ' ' '\n' | sort);
    do
        echo "${fstab_entries[$label]}"
    done
    echo ""
fi

# Print the mergerfs entry
if [ -n "$merger_paths" ]; then
    echo "# MergerFS pool for data disks"
    mergerfs_line="$merger_paths $MERGERFS_MOUNT_POINT mergerfs $MERGERFS_OPTIONS 0 0"
    echo "$mergerfs_line"
fi

echo ""
echo "# --- End of generated entries ---"
