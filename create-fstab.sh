#!/bin/bash

#
# This script scans for Btrfs filesystems with labels 'oceand{nn}' (data)
# and 'oceanp{nn}' (parity). It generates /etc/fstab entries for all of them.
# If a filesystem is on a LUKS encrypted device, it also generates the
# corresponding /etc/crypttab entry.
# Finally, it creates a mergerfs entry to pool only the data disks at /ocean.
# It will print a warning if a duplicate Btrfs label is found.
#

# --- Script Configuration ---
FILESYSTEM_TYPE="btrfs"
# This pattern matches both 'oceand##' and 'oceanp##'
LABEL_PATTERN="^ocean[dp][0-9][0-9]$"
# This pattern matches ONLY data disks for the mergerfs pool
DATA_LABEL_PATTERN="^oceand[0-9][0-9]$"
MOUNT_OPTIONS="defaults,noatime,nofail"

# LUKS configuration
# The script assumes a single, shared key file for all encrypted ocean disks.
# IMPORTANT: Secure this file! (e.g., chmod 600, owned by root)
LUKS_KEY_FILE="/mnt/usb-secrets/ocean_luks_key"
LUKS_OPTIONS="luks,discard"

# MergerFS configuration
MERGERFS_MOUNT_POINT="/ocean"
MERGERFS_RESTRICT_TO_SUBDIR="/ocean" # only share files from each disk's /ocean subdirectory
# Options explained:
# allow_other: lets non-root users see the mount
# use_ino: helps applications that track files by inode
# category.create=eplfs: (Existing Path, Least Free Space) a smart policy for creating new files
# minfreespace=500G: stops writing to a disk when it has less than 500GB free
# fsname=oceanpool: a descriptive name that will appear in commands like `df`
MERGERFS_OPTIONS="defaults,allow_other,use_ino,category.create=eplfs,minfreespace=500G,fsname=oceanpool"

# --- Main Logic ---

# Header for the output
echo "# --- Start of generated crypttab and fstab entries for ocean disks ---"
echo "# Generated by script on $(date)"
echo ""

# Use lsblk to find devices and pipe to awk for processing.
# We ask for NAME, PKNAME, UUID, LABEL, and FSTYPE to understand the device hierarchy.
# NAME is the device name (e.g., sda1, nvme0n1p1)
# PKNAME is the parent device name. For a mapped LUKS device, PKNAME is the physical device.
# We sort by NAME to process physical devices before their children (mapped devices).
lsblk -n -o NAME,PKNAME,UUID,LABEL,FSTYPE | sort -k1 | \
awk -v fstype="$FILESYSTEM_TYPE" \
    -v pattern="$LABEL_PATTERN" \
    -v data_pattern="$DATA_LABEL_PATTERN" \
    -v fstab_options="$MOUNT_OPTIONS" \
    -v luks_key="$LUKS_KEY_FILE" \
    -v luks_opts="$LUKS_OPTIONS" \
    -v mergerfs_mp="$MERGERFS_MOUNT_POINT" \
    -v mergerfs_opts="$MERGERFS_OPTIONS" \
    -v mergerfs_restrict="$MERGERFS_RESTRICT_TO_SUBDIR" \
'
# BEGIN block runs once before processing any input.
BEGIN {
    # This array will store the UUID of physical LUKS devices, keyed by their NAME (e.g., "sda1").
    delete luks_devices;
    # This array tracks seen Btrfs labels to warn about duplicates.
    delete seen_labels;
    # This array will hold the generated crypttab entries to be printed before fstab.
    delete crypttab_entries;
    # This array will hold the generated fstab entries.
    delete fstab_entries;
    # This string will accumulate paths for the mergerfs pool.
    merger_paths = "";
}

# Main processing block. Runs for each line from lsblk.
{
    name = $1
    pkname = $2
    uuid = $3
    label = $4
    fs = $5

    # Stage 1: Identify physical LUKS devices
    # If the filesystem type is crypto_LUKS, it is a physical encrypted device.
    if (fs == "crypto_LUKS") {
        # Store its UUID, keyed by its device name (e.g., "sda1").
        luks_devices[name] = uuid
    }

    # Stage 2: Identify Btrfs filesystems we care about
    # Check if the filesystem type is Btrfs and the label matches our pattern (ocean[dp]##).
    if (fs == fstype && label ~ pattern) {
        # Check for duplicate Btrfs labels.
        if (label in seen_labels) {
            printf "WARNING: Duplicate Btrfs label \\x27%s\\x27 detected. Original UUID: %s, Conflicting UUID: %s. Ignoring conflicting device.\n", label, seen_labels[label], uuid > "/dev/stderr"
            next
        }
        seen_labels[label] = uuid

        mount_point = "/mnt/" label

        # Is this Btrfs filesystem on a LUKS device?
        # We check if its parent device (pkname) is in our array of LUKS devices.
        if (pkname in luks_devices) {
            # --- ENCRYPTED DISK ---
            luks_uuid = luks_devices[pkname]
            # Create the crypttab entry. The mapper name is the Btrfs label.
            crypttab_entries[label] = sprintf("%s UUID=%s %s %s", label, luks_uuid, luks_key, luks_opts)
            # Create the fstab entry using the Btrfs UUID.
            fstab_entries[label] = sprintf("UUID=%s %s %s %s 0 0", uuid, mount_point, fstype, fstab_options)
        } else {
            # --- UNENCRYPTED DISK ---
            # Create a standard fstab entry.
            fstab_entries[label] = sprintf("UUID=%s %s %s %s 0 0", uuid, mount_point, fstype, fstab_options)
        }

        # If it is a data disk, add it to the mergerfs pool list.
        if (label ~ data_pattern) {
            if (merger_paths == "") {
                merger_paths = mount_point mergerfs_restrict
            } else {
                merger_paths = merger_paths ":" mount_point mergerfs_restrict
            }
        }
    }
}

# END block runs once after all input has been processed.
END {
    # Print crypttab entries if any were generated.
    if (length(crypttab_entries) > 0) {
        printf "# --- crypttab entries ---\n"
        # Sort the entries by label (oceand01, oceand02, etc.) for consistent output.
        PROCINFO["sorted_in"] = "@ind_str_asc"
        for (label in crypttab_entries) {
            print crypttab_entries[label]
        }
        printf "\n"
    }

    # Print fstab entries.
    if (length(fstab_entries) > 0) {
        printf "# --- fstab entries for individual disks ---\n"
        PROCINFO["sorted_in"] = "@ind_str_asc"
        for (label in fstab_entries) {
            print fstab_entries[label]
        }
        printf "\n"
    }

    # Print the mergerfs entry if any data disks were found.
    if (merger_paths != "") {
        print "# MergerFS pool for data disks"
        mergerfs_line = sprintf("%s %s %s %s 0 0", merger_paths, mergerfs_mp, "mergerfs", mergerfs_opts)
        print mergerfs_line
    }
}
'

echo ""
echo "# --- End of generated entries ---"